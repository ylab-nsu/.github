# Реализация поддержки RISC-V в проекте [UPX](https://github.com/upx/upx)

UPX - кросс-платформенная утилита для создания самораспаковывающихся исполняемых файлов для различных ОС и систем команд: https://github.com/upx/upx

В лаборатории ведется проект по реализации поддержки системы команд RISC-V в этом проекте.
В настоящее время реализована поддержка RISC-V 64 для исполняемых файлов ELF и ОС Linux, но эта поддержка страдает рядом недостатков и ограничений.

## Обратное проектирование

Одна из главных проблем состоит в том, что UPX - продукт с неполностью открытыми исходниками.  Основной алгоритм упаковки NRV2B не документирован и его реализация отсутствует в публичном репозитории.  В открытом доступе есть лишь упрощенная версия этого алгоритма, известная как UCL и обеспечивающая меньшую степень сжатия.  Распаковщик, внедряемый в результирующий исполняемый файл, поддерживает оба алгоритма упаковки.  Код распаковщика существует лишь в виде плохо документированных исходников на ассемблере для различных целевых архитектур.  

Имеющийся распаковщик для RISC-V получен покомандной конверсией кода AMD64 c  попытками так называемой peephole optimization (оптимизации, состоящие в замене коротких сочетаний команд).  Код заведомо субоптимален, а его улучшение путем peephole optimization весьма трудоемко и неперспективно.  Это позволяет сформулировать несколько направлений для дальнейшей работы.

Работа по покомандной конверсии кода без понимания логики его работы очень трудоемка и скучна. Предлагается все-таки разобраться в алгоритме распаковки UCL/NRV2B, написать документ о формате упакованных данных и реализацию этого алгоритма на языке C.

## Более удачный образец

Большая часть сложностей при покомандной конверсии кода AMD64 в RISC-V была связана с тем, что это процессоры разного типа.  AMD64 - CISC-процессор, главной особенностью которого является то, что почти все команды могут обращаться к операндам в памяти.  RISC-V - это RISC или Load-Store процессор, у которого большинство команд могут работать только с регистрами.  С другой стороны, у RISC-V 31 регистр общего назначения, а у AMD64 их всего 16, поэтому разработанная для AMD64 раскладка данных по регистрам для RISC-V заведомо субоптимальна, а при программировании на ассемблере именно раскладка регистров определяет большую часть структуры кода.

Предлагается взять за основу код распаковщика для процессора, более похожего по параметрам на RISC-V, например, ARM64 (также Load-Store с 31 регистром).

## Фильтры

Сами по себе алгоритмы упаковки, поддерживаемые UPX, архитектурно независимы.  Но в UPX есть понятие “фильтра” - обратимого преобразования кода, в результате которого в нем могут появиться повторяющиеся последовательности байт, что повышает степень сжатия.  Фильтры архитектурно зависимы.  Например, в AMD64 все команды перехода используют относительную адресацию (в адресном смещении лежит разность между адресом команды и адресом точки перехода), поэтому все переходы в одну точку (например, вызовы одной и той же функции) имеют разное значение адресного поля.  Заменив такие адреса на абсолютные, мы можем получить искомые повторяющиеся последовательности байт.

Проект начат в рамках [Bootcamp 2025](https://github.com/ylab-nsu#bootcamp-2025), приватный репозиторий https://github.com/ylab-nsu/upx-filters .

Окончательная задача состоит в том, чтобы научиться создавать такие фильтры и оценить выигрыш в степени сжатия, которые дает их применение.  Конечная цель - найти все возможные для RISC-V фильтры, которые могли бы дать сколько-нибудь значительный выигрыш.

## Поддержка разделяемых библиотек

В настоящее время наша версия UPX/RISC-V поддерживает только статические и динамические исполняемые файлы формата ELF.  Кроме них, UPX также поддерживает разделяемые библиотеки (файлы .so), но для RISC-V это не реализовано.  Задача данного проекта - сделать это.

Главная сложность этого проекта состоит в том, что распаковщик (стаб) для разделяемой библиотеки должен создавать не такие сегменты, какие присутствуют в образе обычного исполняемого файла, и добавлять в распакованный образ структуры, которых у исполняемого файла просто нет, например, таблицы символов, корректно настраивая их с учетом размещения библиотеки в памяти.  Часть этой логики архитектурно зависима, а функционально аналогичные модули для поддерживаемых архитектур реализованы на ассемблере.

## Распознавание упакованных файлов

С точки зрения заказчика конечная цель проекта - научиться распознавать файлы, упакованные UPX.  Дело в том, что много вредоносного ПО распространяется в упакованном виде, что сильно затрудняет распознавание такого кода антивирусами и аналогичными инструментами.  В частности, уже сейчас мы имеем две сильно различающиеся версии распаковщика для RISC-V (“оптимизированную” и “неоптимизированную”), а по итогам проектов [Обратное проектирование](#Обратное-проектирование) и [Более удачный образец](#Более-удачный-образец) мы можем получить еще несколько версий кода, возможно, не имеющие никаких общих сигнатур.

Задача состоит в том, чтобы найти инвариант кода UPX, который крайне сложно устранить без нарушения функциональности этой программы.  Наиболее интересное направление поиска - это анализ последовательности системных вызовов, которые делает этот код.  Для построения такой последовательности необходимо запустить исполняемый файл в специальным образом настроенном эмуляторе и остановить его до того, как он передаст управление на распакованный код.






